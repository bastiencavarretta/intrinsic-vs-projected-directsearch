import pymanopt as mo
import numpy as np
import numpy.linalg as lg
import pymanopt.manifolds as man
from dataclasses import dataclass
from pymanopt.manifolds.manifold import Manifold
import scipy.linalg
import scipy.stats
import scipy
from tools.utils_cm_hypersphere import *



##############################################################################################################################
# Defining Manifold classes needed for problem class

class NullManifold(Manifold):
    """Null Manifold compatible with pymanopt.
    Args:
        manifold : a pymanopt manifold, embedded in a linear space E (same shape as the points of the manifold)
    Returns:
        pymanopt Manifold object : the null submanifold of E
    """
    def __init__(self,manifold):
        self._probepoint = manifold.random_point()
        super().__init__(name="Null manifold", dimension=0)
        self._npoint = np.zeros_like(self._probepoint) 
    
    @property
    def typical_dist(self): 
        return 0.0
    def projection(self, point, tangent_vector):
        return self._npoint

    def random_point(self):
        return self._npoint
    
    def random_tangent_vector(self, point):
        return self._npoint
    
    def zero_vector(self, point):
        return self._npoint
    
    def inner_product(self, point, tangent_vector_a, tangent_vector_b):
        return 0.0

    def norm(self, point, tangent_vector):
        return 0.0

    def dist(self, point_a, point_b):
        return 0.0
    
    def euclidean_to_riemannian_gradient(self, point, euclidean_gradient):
        return self._npoint

    def exp(self, point, tangent_vector):
        return self._npoint
    retraction = exp
    
    def log(self, point_a, point_b):
        return self._npoint

    def pair_mean(self, point_a, point_b):
        return self._npoint

    to_tangent_space = projection

    def transp(self, point_a, point_b, tangent_vector):
        return self._npoint

class LinearSubspace(Manifold):
    """Linear subspace of R^n
    Args:
        A : Stiefel matrix of shape (n,m)
    Returns:
        pymanopt Manifold object : the linear subspace of R^n generated by the columns of A
    """

    def __init__(self, A):
        self._n, self._m = A.shape
        self.A = A

        name = f"Im(A)"
        dimension = self._m 
        super().__init__(name, dimension) 

    @property
    def dimension(self):
        return self._dimension 
    
    @property
    def typical_dist(self): 
        raise(NotImplementedError)

    def inner_product(self, point, tangent_vector_a, tangent_vector_b):
        return np.tensordot(
            tangent_vector_a,
            tangent_vector_b,
            axes=tangent_vector_a.ndim,
        )

    def projection(self, point, tangent_vector):
        coeffs  = np.dot(tangent_vector, self.A)
        proj = np.dot(self.A,coeffs)
        return proj

    to_tangent_space = projection

    def norm(self, point, tangent_vector):
        return np.sqrt(
            self.inner_product(point, tangent_vector, tangent_vector)
        )

    def random_point(self):
        coeffs = np.random.randn(self._m)
        point = np.dot(self.A,coeffs)
        return point
 
    def random_tangent_vector(self, point): # pymanopt random tangent vectors must be unitary
        vector = self.random_point() #points and tangent vectors leave in the same space
        return vector / self.norm(point, vector)

    def zero_vector(self, point):
        return np.zeros_like(point)

    def dist(self, point_a, point_b):
        return np.sqrt(np.linalg.norm(point_a-point_b, ord = 2))
    
    def euclidean_to_riemannian_gradient(self, point, euclidean_gradient):
        return self.projection(point,euclidean_gradient)
    
    def exp(self, point, tangent_vector):
        return point + tangent_vector

    retraction = exp

    def log(self, point_a, point_b):
        return point_b - point_a

    def pair_mean(self, point_a, point_b):
        return self.exp(point_a, self.log(point_a, point_b) / 2)




############################################################################################################################### Defining the problems classes

@dataclass
class ProblemLinearSubspace:
    """
    Build a minimization problem on a linear subspace of R^n, with all required methods to run the directsearch.

    Args: 
        B (np.ndarray) : Stiefel matrix of shape (n,m). m must be larger than 2 and n.
        obj (int) : 1 or 2 or 3
    Note:
        The linear subspace is defined as the image of the Stiefel matrix B.
        If obj == 1, the problem corresponds to the barycenter of points in the linear subspace.
        If obj == 2, the problem corresponds to the barycenter of points in the ambient space R^n (constrained to the linear subspace).
        If obj == 3, the objective is a quadratic function.
    """
    
    B : np.ndarray # Stiefel matrix of shape (n,m). m must 
    obj : int = 1
    def __post_init__(self): #adim = ambient dim
        self.manifold = LinearSubspace(self.B)
        self.adim = self.B.shape[0]
        self.mdim = self.manifold.dimension
        self.codim = self.adim-self.mdim
        self.anorm = lambda x : scipy.linalg.norm(x,ord = 2) # ambient norm = euclidean norm since embedded submanifold
        self.xstart = self.manifold.random_point()


        if self.obj == 1: # Barycenter problem of points in the linear subspace
            self.xref = self.manifold.random_point()
            self.xrefdirections =  [self.manifold.random_tangent_vector(self.xref) for i in range(10)]
            self.xpoints = [self.manifold.exp(self.xref, v) for v in self.xrefdirections]
            self.xstar = np.mean(np.array(self.xpoints),axis = 0)

        elif self.obj == 2:  # Barycenter problem of points in the ambient subspace R^n
            self.xref = np.random.randn(self.adim)
            self.xrefdirections =  [np.random.rand(self.adim) for i in range(10)]
            self.xpoints = [self.xref+ v for v in self.xrefdirections]
            self.xstar = self.manifold.projection(1967,np.mean(np.array(self.xpoints),axis = 0)) 
        
        elif self.obj == 3 : # Quadratic objective function
            rdmmatrix = np.random.randn(self.adim,self.adim)
            self.A = rdmmatrix.dot(rdmmatrix.T) + 0.1*np.eye(self.adim,dtype=float)
            self.b = np.random.randn(self.adim)
        else:
            raise ValueError("objective not defined")
        
        self.fstart = self.costf(self.xstart)

    def costf(self,x):
        if self.obj == 1:
            cost = 0 
            for point in self.xpoints:
                cost = cost + self.manifold.dist(point,x)**2
            cost = cost/len(self.xpoints)
            return cost
        
        elif self.obj == 2:
            cost = 0
            for point in self.xpoints:
                cost = cost + np.linalg.norm(x-point,ord = 2)**2
            cost = cost/len(self.xpoints)
            return cost
        elif self.obj == 3:
            return ((self.A).dot(x).dot(x))/2 -(self.b).dot(x)
        else:
            raise ValueError("non defined objective")

    
    def build_pss(self,x,projection = 0,psstype = 1, rotation = 0,renormalize=True,tolerance = 1e-16,returnlostvecnumber = 0):
        """Building the positive spanning set of the tangent space at point x
        Args:
            x : point on the manifold
            projection (int) : 0 or 1. Whether the pss is intrinsic (0) or projected (1)
            psstype (int) : 1,2 or 3. Type of positive spanning set to build (same order as table 1 in the paper)
            rotation (int) : 0 or 1. Whether to apply a random rotation to the basis before building the pss
            renormalize (bool) : whether to renormalize the vectors of the pss after projection
            tolerance (float) : tolerance to remove small "null" vectors after projection
            returnlostvecnumber (int) : 0 or 1. Whether to return the number of lost vectors after projection or not (for test purposes only)
        Returns :
            pss (np.ndarray) : array of shape (nb_vectors, dimension of the ambient space). Each row is a vector of the positive spanning set.
        """
        if projection == 1: #projected pss
            base = np.eye(self.adim)
            #applying rotation to basis
            if rotation == 1:
                rotmat=scipy.stats.ortho_group.rvs(self.adim)
                base = base.dot(rotmat)
            #defining the ambient pss
            if psstype == 1:
                pss = np.concatenate((base,-base),axis = 1)
            elif psstype == 2:
                negatedsum = -np.sum(base,axis = 1).reshape(-1,1)
                negatedsum = negatedsum/np.linalg.norm(negatedsum,ord = 2)
                pss = np.concatenate((base,negatedsum),axis = 1)
            elif psstype == 3: 
                GramMatrix = (-1/self.adim)*np.ones((self.adim,self.adim)) + (1+1/self.adim)*np.eye(self.adim) 
                L = scipy.linalg.cholesky(GramMatrix)
                pss = base.dot(L)
                negatedsum = -np.sum(pss,axis = 1).reshape(-1,1)
                pss  = np.concatenate((pss,negatedsum), axis = 1)

            #projecting the pss
            pss = np.array([self.manifold.projection(x, pss[:,i]) for i in range(pss.shape[1])]).T

            # removing zero vectors
            pssstar = []
            for vec in pss.T:
                if self.manifold.norm(x,vec) > tolerance: 
                    pssstar.append(vec)
            pssstar = np.array(pssstar).T
            nblostvec = pss.shape[1]-pssstar.shape[1]
            pss = pssstar

            #renormalizing
            if renormalize == True: 
                pss = pss/np.linalg.norm(pss,ord = 2, axis = 0,keepdims=True) 

        else : # intrinsic pss
            base = self.B.copy()
            #applying rotation to basis 
            if rotation == 1:
                rotmat=scipy.stats.ortho_group.rvs(self.mdim)
                base = base.dot(rotmat)
            #defining the pss
            if psstype == 1:
                pss = np.concatenate((base,-base),axis = 1)
            elif psstype == 2:
                negatedsum = -np.sum(base,axis = 1).reshape(-1,1)
                negatedsum = negatedsum/self.manifold.norm(x,negatedsum)
                pss = np.concatenate((base,negatedsum),axis = 1)
            elif psstype == 3:
                GramMatrix = (-1/self.mdim)*np.ones((self.mdim,self.mdim)) + (1+1/self.mdim)*np.eye(self.mdim) 
                L = scipy.linalg.cholesky(GramMatrix)
                pss = base.dot(L)
                negatedsum = -np.sum(pss,axis = 1).reshape(-1,1)
                pss  = np.concatenate((pss,negatedsum), axis = 1)
        if returnlostvecnumber == 1:
            return pss.T,nblostvec
        else :
            return pss.T 


@dataclass
class ProblemEigh:
    """Build a minimization problem on a sphere in R^n, with all required methods to run the directsearch.
    Args: 
        adim (int) : ambient dimension
        mdim (int) : manifold dimension. mdim>=2.
    Note:
        The manifold is a sphere of dimension mdim embedded in R^{mdim+1}, concatenated with a null manifold of dimension adim - (mdim+1).
    """
    adim : int
    mdim : int
    def __post_init__(self): 
        self.codim = self.adim-self.mdim
        self.manifold =  man.Product([mo.manifolds.Sphere(self.mdim+1),NullManifold(man.Euclidean(self.codim-1))])
        self.anorm = lambda x : np.sqrt(scipy.linalg.norm(x[0],ord = 2)**2 + scipy.linalg.norm(x[1],ord = 2)**2) # ambient norm = euclidean norm since embedded submanifold
        A = np.random.randn(self.mdim+1,self.mdim+1)
        self.A = (A+A.T)/2
        self.xstart = self.manifold.random_point()
        self.fstart = self.costf(self.xstart)
    
    def costf(self,x):
        value = np.dot(self.A,x[0]).dot(x[0])
        return value
    
    def build_pss(self,x,projection = 0,psstype = 1, rotation = 0,renormalize=True,tolerance = 1e-16,returnlostvecnumber = 0):
        """Building the positive spanning set of the tangent space at point x
        Args:
            x : point on the manifold
            projection (int) : 0 or 1. Whether the pss is intrinsic (0) or projected (1)
            psstype (int) : 1,2 or 3. Type of positive spanning set to build (same order as table 1 in the paper)
            rotation (int) : 0 or 1. Whether to apply a random rotation to the basis before building the pss
            renormalize (bool) : whether to renormalize the vectors of the pss after projection
            tolerance (float) : tolerance to remove small "null" vectors after projection
            returnlostvecnumber (int) : 0 or 1. Whether to return the number of lost vectors after projection or not (for test purposes only)
        Returns :
            pss (list) : list of vectors of the tangent space (compatible with the manifold type), forming a positive spanning set.
        """

        x0,x1 = x
        if projection == 1: 
            abase_U = np.eye(self.mdim+1)
            abase_V = np.eye(self.codim-1)
            abase = []
            for vec in abase_U:
                abase.append(np.hstack((vec,np.zeros(self.codim - 1))))
            for vec in abase_V:
                abase.append(np.hstack((np.zeros(self.mdim+1),vec)))
            abase = np.array(abase).T # each column is a vector

            #applying rotation to basis
            if rotation ==  1:
                rotmat=scipy.stats.ortho_group.rvs(self.adim)
                base = abase.dot(rotmat)
            else :
                base = abase
        
            # Defining the ambient pss
            if psstype == 1:
                apss = np.concatenate((base,-base),axis = 1)
            elif psstype == 2:
                negatedsum = -np.sum(base,axis = 1).reshape(-1,1)
                negatedsum = negatedsum/np.linalg.norm(negatedsum,ord = 2)
                apss = np.concatenate((base,negatedsum),axis = 1)
            elif psstype == 3: 
                GramMatrix = (-1/self.adim)*np.ones((self.adim,self.adim)) + (1+1/self.adim)*np.eye(self.adim) 
                L = scipy.linalg.cholesky(GramMatrix)
                apss = base.dot(L)
                negatedsum = -np.sum(apss,axis = 1).reshape(-1,1)
                apss  = np.concatenate((apss,negatedsum), axis = 1)   

            #projecting the pss
            pss = []
            for vec in apss.T:
                pymanoptvec = [vec[:self.mdim+1],vec[self.mdim+1:]]
                pvec = self.manifold.projection(x, pymanoptvec)
                # removing zero vectors
                pvecnorm = self.manifold.norm(x,pvec)
                if pvecnorm > tolerance: # removing zero vectors
                    if renormalize == True : # renormalizing nonzero vectors
                        pvec = pvec/pvecnorm
                    pss.append(pvec)
            nblostvec = len(apss.T) - len(pss)
            pymanoptpss = pss

            # remark : if no rotation was applied, then many vectors are aligned with the axes. After projection, they are removed. The projected method will thus have roughly as many vectors as the intrinsic one.


        elif projection == 0:
            # basis 
            base_U = np.random.randn(self.mdim+1,self.mdim+1) 
            base_U[:,0] = x[0]
            base_U,_ = lg.qr(base_U)
            base_U = base_U[:,1:]
            base = np.vstack((base_U,np.zeros((self.codim-1, self.mdim))))
            #applying rotation to basis 
            if rotation == 1:
                rotmat = scipy.stats.ortho_group.rvs(self.mdim)
                base = base.dot(rotmat)
            #defining the pss
            if psstype == 1:
                pss = np.concatenate((base,-base),axis = 1)
            elif psstype == 2:
                negatedsum = -np.sum(base,axis = 1).reshape(-1,1)
                negatedsum = negatedsum/self.anorm(negatedsum) 
                pss = np.concatenate((base,negatedsum),axis = 1)

            elif psstype == 3: 
                GramMatrix = (-1/self.mdim)*np.ones((self.mdim,self.mdim)) + (1+1/self.mdim)*np.eye(self.mdim) 
                L = scipy.linalg.cholesky(GramMatrix)
                pss = base.dot(L)
                negatedsum = -np.sum(pss,axis = 1).reshape(-1,1)
                pss  = np.concatenate((pss,negatedsum), axis = 1)
            pymanoptpss = []
            for vec in pss.T:
                pymanoptpss.append([vec[:self.mdim+1], vec[self.mdim+1:]])

        if returnlostvecnumber == 1:
            return pymanoptpss,nblostvec
        else :
            return pymanoptpss